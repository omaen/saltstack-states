### Common init and functions for iptables-gen

error_handler () {
    script_name="$0"
    line="$1"
    exit_code="$2"
    echo "${script_name}: Error in line $line (exit code ${exit_code})"
    exit $exit_code
}

trap 'error_handler ${LINENO} $?' ERR INT TERM
set -o errtrace -o pipefail

iptables_raw=("*raw")
iptables_filter=("*filter")
iptables_mangle=("*mangle")
iptables_nat=("*nat")
ip6tables_filter=("*filter")
ip6tables_mangle=("*mangle")
ip6tables_nat=("*nat")
ip6tables_raw=("*raw")
ipset_rules=()

declare -A interfaces
declare -A network_groups
declare -A ip_groups

NETNS=$(ip netns identify $$)
ETC="/etc"

if [[ -n ${NETNS} ]]; then
    ETC="/etc/netns/${NETNS}"
    [[ -d ${ETC} ]] || mkdir -p "${ETC}"
fi

IPSETS_RESTORE="${ETC}/ipsets.restore"
IPTABLES_RESTORE="${ETC}/iptables.restore"
IP6TABLES_RESTORE="${ETC}/ip6tables.restore"


# %{zone} is used for automatic zone interface substitutions as iptables itself does not
# support multiple interfaces in one rule. Perl is used because bash regex does not
# support non-greedy matching which is essential when both in and out zone substitution is used
# in the same rule.
get_zone () {
    local rule="$1"
    perl -e 'my $rule = $ARGV[0]; if ($rule =~ /(?:.+\s)?%\{(.+?)\}\s.+/) { print $1; }' -- "$rule"
}

expand_zone_interfaces () {
    local zone="$1"
    local rule="$2"

    for interface in ${interfaces[${zone}]}; do
        perl -e 'my $rule = $ARGV[0]; my $interface = $ARGV[1]; if ($rule =~ /(.+\s)?%\{.+?\}(\s.+)/) { print join("", $1, $interface, $2, "\n"); }' -- "$rule" $interface
    done
}

parse_iptables_rule () {
    local rule_unparsed="$1"
    local zone=$(get_zone "$rule")

    if [[ -n $zone ]]; then
        # Iterate over the generated rules until all zones in the rule are substituted with
        # iptables compatible interface rules.
        while read -r rule; do
            parse_iptables_rule "$rule"
        done <<< "$(expand_zone_interfaces $zone "${rule_unparsed}")"
    else
        echo "$rule"
    fi
}

print_ipset_rules () {
    for rule in "${ipset_rules[@]}"; do
        echo "$rule"
    done
}

print_iptables_rules () {
    for rule in "${iptables_raw[@]}"; do
        parse_iptables_rule "$rule"
    done

    for rule in "${iptables_nat[@]}"; do
        parse_iptables_rule "$rule"
    done

    for rule in "${iptables_mangle[@]}"; do
        parse_iptables_rule "$rule"
    done

    for rule in "${iptables_filter[@]}"; do
        parse_iptables_rule "$rule"
    done
}

print_ip6tables_rules () {
    for rule in "${ip6tables_nat[@]}"; do
        parse_iptables_rule "$rule"
    done

    for rule in "${ip6tables_mangle[@]}"; do
        parse_iptables_rule "$rule"
    done

    for rule in "${ip6tables_filter[@]}"; do
        parse_iptables_rule "$rule"
    done

    for rule in "${ip6tables_raw[@]}"; do
        parse_iptables_rule "$rule"
    done
}

reset_ipv4_policies () {
    iptables_filter=("*raw")
    for CHAIN in PREROUTING OUTPUT; do
        iptables_filter+=(":${CHAIN} ACCEPT")
    done

    iptables_filter=("*filter")
    for CHAIN in INPUT FORWARD OUTPUT; do
        iptables_filter+=(":${CHAIN} ACCEPT")
    done

    iptables_mangle=("*mangle")
    for CHAIN in PREROUTING INPUT FORWARD OUTPUT POSTROUTING; do
        iptables_mangle+=(":${CHAIN} ACCEPT")
    done

    iptables_nat=("*nat")
    for CHAIN in PREROUTING INPUT OUTPUT POSTROUTING; do
        iptables_nat+=(":${CHAIN} ACCEPT")
    done
}

reset_ipv6_policies () {
    ip6tables_filter=("*filter")
    for CHAIN in INPUT FORWARD OUTPUT; do
        ip6tables_filter+=(":${CHAIN} ACCEPT")
    done

    ip6tables_mangle=("*mangle")
    for CHAIN in PREROUTING INPUT FORWARD OUTPUT POSTROUTING; do
        ip6tables_mangle+=(":${CHAIN} ACCEPT")
    done

    ip6tables_nat=("*nat")
    for CHAIN in PREROUTING OUTPUT POSTROUTING; do
        ip6tables_nat+=(":${CHAIN} ACCEPT")
    done

    ip6tables_raw=("*raw")
    for CHAIN in PREROUTING OUTPUT; do
        ip6tables_raw+=(":${CHAIN} ACCEPT")
    done
}

rollback () {
    if [[ -f ${IPSETS_RESTORE} ]]; then
        ipset restore < "${IPSETS_RESTORE}"
    else
        ipset_rules=()
        commit_ipsets
    fi

    if [[ -f ${IPTABLES_RESTORE} ]]; then
        iptables-restore < "${IPTABLES_RESTORE}"
    else
        reset_ipv4_policies
        commit_ipv4_rules
    fi

    if [[ -f ${IP6TABLES_RESTORE} ]]; then
        ip6tables-restore < "${IP6TABLES_RESTORE}"
    else
        reset_ipv6_policies
        commit_ipv6_rules
    fi

    store
}

commit_ipsets () {
    print_ipset_rules | ipset restore
}

commit_ipv4_rules () {
    iptables_raw+=("COMMIT")
    iptables_filter+=("COMMIT")
    iptables_mangle+=("COMMIT")
    iptables_nat+=("COMMIT")

    print_iptables_rules | iptables-restore
}

commit_ipv6_rules () {
    ip6tables_filter+=("COMMIT")
    ip6tables_mangle+=("COMMIT")
    ip6tables_nat+=("COMMIT")
    ip6tables_raw+=("COMMIT")

    print_ip6tables_rules | ip6tables-restore
}

store () {
    print_ipset_rules > "${IPSETS_RESTORE}"
    iptables-save > "${IPTABLES_RESTORE}"
    ip6tables-save > "${IP6TABLES_RESTORE}"
}

commit () {
    local STORE="$1"

    add_ipsets

    commit_ipsets
    commit_ipv4_rules
    commit_ipv6_rules

    if [[ ${STORE} != "--no-store" ]]; then
        store
    fi
}

commit_confirm () {
    ROLLBACK_DELAY=30
    TIMESTAMP=$(date +"%s")

    echo "Rolling back the ruleset in ${ROLLBACK_DELAY} seconds if not confirmed."
    commit --no-store

    echo -e "\nThe ruleset has been applied successfully!"
    WAIT=true

    while ${WAIT}; do
        TIMEOUT=$(( ${TIMESTAMP} + ${ROLLBACK_DELAY} - $(date +"%s") ))

        # If the timeout is reached read returns with an error code > 128 which
        # hits the error traps. Ensure it always returns true.
        echo ""
        read -p "Press 'Y' to make the new ruleset persistent, 'N' to rollback immediately: " \
            -n 1 -r -t ${TIMEOUT} || true

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo -e "\nConfirmation received. Making ruleset persistent.\n"
            store
            WAIT=false
        elif [[ $REPLY =~ ^[Nn]$ || ${TIMEOUT} -le 0 ]]; then
            echo -e "\nRolling back to the previous ruleset.\n"
            rollback
            WAIT=false
        fi
    done
}

add_ipsets () {
    for set_name in ${!network_groups[@]}; do
        ipset_rules+=("create $set_name hash:net -exist")
        ipset_rules+=("flush $set_name")

        for net in ${network_groups[$set_name]}; do
            ipset_rules+=("add $set_name $net")
        done
    done

    for set_name in ${!ip_groups[@]}; do
        ipset_rules+=("create $set_name hash:ip -exist")
        ipset_rules+=("flush $set_name")

        for ip in ${ip_groups[$set_name]}; do
            ipset_rules+=("add $set_name $ip")
        done
    done
}

add_filter_dispatchers () {
    for zone in ${!interfaces[@]}; do
        for chain in INPUT FORWARD OUTPUT; do
            zone_chain="${zone}_${chain}"
            iptables_filter+=(":${zone_chain} -")

            if [[ $chain == "OUTPUT" ]]; then
                iptables_filter+=("-A $chain -o %{$zone} -j $zone_chain")
            else
                iptables_filter+=("-A $chain -i %{$zone} -j $zone_chain")
            fi
        done
    done
}

add_nat_dispatchers () {
    for zone in ${!interfaces[@]}; do
        for chain in PREROUTING INPUT OUTPUT POSTROUTING; do
            zone_chain="${zone}_${chain}"
            iptables_nat+=(":${zone_chain} -")

            if [[ $chain == "OUTPUT" ]] || [[ $chain == "POSTROUTING" ]]; then
                iptables_nat+=("-A $chain -o %{$zone} -j $zone_chain")
            else
                iptables_nat+=("-A $chain -i %{$zone} -j $zone_chain")
            fi
        done
    done
}

add_mangle_dispatchers () {
    for zone in ${!interfaces[@]}; do
        for chain in PREROUTING INPUT FORWARD OUTPUT POSTROUTING; do
            zone_chain="${zone}_${chain}"
            iptables_mangle+=(":${zone_chain} -")

            if [[ $chain == "OUTPUT" ]] || [[ $chain == "POSTROUTING" ]]; then
                iptables_mangle+=("-A $chain -o %{$zone} -j $zone_chain")
            else
                iptables_mangle+=("-A $chain -i %{$zone} -j $zone_chain")
            fi
        done
    done
}

add_filter_defaults () {
    iptables_filter+=(
        "-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"
        "-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"
        "-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"
        "-A INPUT -i lo -j ACCEPT"
        "-A OUTPUT -o lo -j ACCEPT"
    )
}

add_filter_helpers () {
    # By default REJECT returns icmp port unreachable for all protocols.
    # This ensures TCP RST is used for TCP
    iptables_filter+=(
        ":CUSTOM_REJECT -"
        "-A CUSTOM_REJECT -p tcp -j REJECT --reject-with tcp-reset"
        "-A CUSTOM_REJECT -j REJECT --reject-with icmp-port-unreachable"
    )
}

add_common_filter_rules () {
    add_filter_defaults
    add_filter_helpers
    add_filter_dispatchers
}

add_common_nat_rules () {
    add_nat_dispatchers
}

add_common_mangle_rules () {
    add_mangle_dispatchers
}

# vim: set filetype=zsh :
